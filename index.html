<!DOCTYPE html>
<meta charset="utf-8">
<meta name="viewport" content="initial-scale=1,maximum-scale=1,user-scalable=no">
<title>3D Earth with Mapbox GL, D3.js and Three.js</title>
<style>
html, body { margin: 0; padding: 0; overflow: hidden; }
html { background-color: #000; color: #fff; font-family: sans-serif; }
#map { position: absolute; pointer-events: none; right: 0; bottom: 0; transform: scale(.25); transform-origin: bottom right; opacity: 0; }
#equirectangular-map { position: absolute; width: 300px; pointer-events: none; right: 0; opacity: 0; }
#loader { position: absolute; left: 10px; top: 10px; }
#style-selector { position: absolute; top: 10px; right: 10px; z-index: 99999; }
#container canvas { vertical-align: top; }
#container > div { bottom: 0; top: auto !important; }
footer { position: absolute; bottom: 10px; right: 10px; opacity: .75; }
footer a { color: inherit; }
</style>
<div id="map"></div>
<canvas id="equirectangular-map"></canvas>
<div id="container"></div>
<div id="loader">Loading&hellip;</div>
<select id="style-selector" onChange="changeStyle(this.value)">
  <option value="satellite" selected>Satellite</option>
  <option value="streets">Streets</option>
  <option value="dark">Dark</option>
  <option value="light">Light</option>
</select>
<footer>
  <a href="https://github.com/cheeaun/3d-earth" target="_blank">Learn more on GitHub</a>
</footer>
<script src="https://api.mapbox.com/mapbox-gl-js/v0.39.1/mapbox-gl.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/d3-geo/1.6.4/d3-geo.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/87/three.min.js"></script>
<script src="https://unpkg.com/camera-controls@0.0.6/dist/camera-controls.min.js"></script>
<script src="https://rawgit.com/mrdoob/stats.js/master/build/stats.min.js"></script>
<script>
var mapWidth = 1200;
var mapHeight = 1200;
// Can bump up these values for higher resolution

var $map = document.getElementById('map');
$map.style.width = mapWidth + 'px';
$map.style.height = mapHeight + 'px';

mapboxgl.accessToken = 'pk.eyJ1IjoiY2hlZWF1biIsImEiOiJjaXhmb3o3bTEwMDAzMnRudTJuNjh1eXQ1In0.yO6WeKJwx6yIPoVx5aPavQ';
var map = new mapboxgl.Map({
  container: 'map',
  style: 'mapbox://styles/mapbox/satellite-v9?optimize=true',
  center: [0, 0],
  zoom: 1,
  interactive: false,
  renderWorldCopies: false,
  attributionControl: false,
  trackResize: false,
  preserveDrawingBuffer: true,
});

var $eMap = document.getElementById('equirectangular-map');
var $loader = document.getElementById('loader');

var $styleSelector = document.getElementById('style-selector');
var mapStyle = 'satellite';
function changeStyle(style){
  console.log('New style: ' + style);
  mapStyle = style;
  map.setStyle('mapbox://styles/mapbox/' + style + '-v9?optimize=true');
  $styleSelector.disabled = true;
}

var width = mapWidth*2;
var height = mapHeight*2;

var equirectangular = d3.geoEquirectangular()
  .scale(height / (2 * Math.PI))
  .translate([width / 2, height / 2]);

var mercator = d3.geoMercator()
  .scale(width / (2 * Math.PI))
  .translate([width / 2, height / 2]);

var invert = equirectangular.invert;

var container = document.getElementById('container');
var camera = new THREE.PerspectiveCamera(80, window.innerWidth / window.innerHeight, 1, 2000);
camera.position.z = 500;
var scene = new THREE.Scene();
scene.background = new THREE.Color(0x000000);
var texture = new THREE.CanvasTexture($eMap);
texture.minFilter = THREE.LinearFilter; // Fix "Textures should be of a power of two" warning
var geometry = new THREE.SphereGeometry(200, 30, 30);
var material = new THREE.MeshBasicMaterial({
  overdraw: .5, // fill in the gaps between triangles
});
var mesh = new THREE.Mesh(geometry, material);
scene.add(mesh);

var renderer = new THREE.WebGLRenderer({
  antialias: true,
  stencil: false,
});
renderer.setPixelRatio(window.devicePixelRatio);
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.context.getShaderInfoLog = function(){ return '' };
container.appendChild(renderer.domElement);

var CameraControls = cameraControlsFactory(THREE);
var cameraControls = new CameraControls(camera, renderer.domElement);
cameraControls.rotate(0, -.8, true);
cameraControls.update();

var stats = new Stats();
// stats.showPanel(1);
container.appendChild(stats.domElement);

// Hack cameraControls to have min & max distance
var _dolly = cameraControls.dolly;
cameraControls.dolly = function(distance, enableTransition){
  var d = Math.abs(distance);
  if (d < 18 || d > 60) return;
  _dolly.call(cameraControls, distance, enableTransition);
}

var stopRotating = false;
container.ontouchstart = container.onmousedown = function(){
  stopRotating = true;
}
container.ontouchend = container.ontouchcancel = container.onmouseup = function(){
  stopRotating = false;
}

window.onresize = function(){
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
}

function animate(){
  requestAnimationFrame(animate);
  render();
  stats.update();
}

const clock = new THREE.Clock();
function render(){
  var delta = clock.getDelta();
  cameraControls.update(delta);
  if (!stopRotating) mesh.rotation.y += .003;
  renderer.render(scene, camera);
}
animate();

map.on('load', function(){
  var canvas = map.getCanvas();
  var gl = canvas.getContext('webgl', { alpha: false, antialias: false });

  var currentStyle = null;
  function render(){
    if (!map.areTilesLoaded() || !map.isStyleLoaded()) return;
    if (currentStyle == mapStyle) return;
    currentStyle = mapStyle;

    console.log('Style loaded');
    $styleSelector.disabled = true;
    $loader.hidden = false;

    setTimeout(function(){
      console.log('Render map start');
      var source = new Uint8Array(gl.drawingBufferWidth * gl.drawingBufferHeight * 4);
      gl.readPixels(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight, gl.RGBA, gl.UNSIGNED_BYTE, source);
      var sourceData = new Uint8ClampedArray(source.buffer);
      var targetData = new Uint8ClampedArray(sourceData.length).fill(255);

      // This part is really slow >:(
      console.time('Reprojection');
      var w = width;
      var h = height;
      var x = 0;
      var y;
      for (; x < w; x++){
        for (y = 0; y < h; y++){
          var pixels = mercator(invert([x, y]));
          if (!isNaN(pixels[1])){
            var sourceIndex = 4 * (~~pixels[0] + w * ~~pixels[1]);
            var targetIndex = 4 * (x + w * y);
            targetData[targetIndex] = sourceData[sourceIndex];
            targetData[targetIndex + 1] = sourceData[sourceIndex + 1];
            targetData[targetIndex + 2] = sourceData[sourceIndex + 2];
            // targetData[targetIndex + 3] = 255; // Already filled
          }
        }
      }
      console.timeEnd('Reprojection');

      var context = $eMap.getContext('2d', { alpha: false });
      var target = context.createImageData(width, height);
      target.data.set(targetData);

      // No idea why the height suddenly change
      // Should have been `height/2` (1200) but somehow the reprojection returns this
      var newHeight = 1135;

      $eMap.width = width;
      $eMap.height = newHeight;
      context.clearRect(0, 0, width, newHeight);
      context.putImageData(target, 0, -633);
      context.translate(0, newHeight);
      context.scale(1, -1);
      context.drawImage($eMap, 0, 0);
      console.log('Render map end');

      $styleSelector.disabled = false;
      $loader.hidden = true;

      if (!material.map){
        material.map = texture;
        material.needsUpdate = true;
      }
      texture.needsUpdate = true;
    }, 350); // Delay for the tiles to render properly
  };

  render();
  map.on('render', render);
});
</script>
